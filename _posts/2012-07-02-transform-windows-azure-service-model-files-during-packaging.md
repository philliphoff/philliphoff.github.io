---
layout: posts
title: "Transform Windows Azure Service Model Files During Packaging"
date: 2012-07-02
---
<p>The latest versions of the Windows Azure Tools for Visual Studio have the ability to maintain multiple versions of the Service Configuration (.cscfg) file.&nbsp; The developer is then prompted to select the version to accompany a deployment, whether it&rsquo;s going to Windows Azure or the development fabric (i.e. the emulator).&nbsp; However, sometimes a developer needs to do something a little more dynamic, where elements of the Service Configuration file must be generated on-the-fly before deployment.</p>
<p>The Tools generate a Windows Azure package via a process driven by MSBuild.&nbsp; The process already performs certain transformations of the Service Configuration file from the original hosted by the project.&nbsp; These transformations include:</p>
<ul>
<li>Adding configuration setting values when IntelliTrace or Profiling are enabled during publishing</li>
<li>Adding configuration setting values when Remote Desktop is enabled during publishing</li>
<li>Adding endpoints when WebDeploy is enabled</li>
</ul>
<p>This transformation process is easily extensible (for certain definitions of &ldquo;easy&rdquo;).&nbsp; To do this, some of the MSBuild concepts you will need are:</p>
<ul>
<li><strong><span style="font-family: Courier New;" face="Courier New">TargetProfile</span>:</strong> This MSBuild property corresponds to the configuration selected for packaging or deployment, e.g. &ldquo;Local&rdquo; or &ldquo;Cloud&rdquo;.</li>
<li><strong><span style="font-family: Courier New;" face="Courier New">SourceServiceConfiguration</span>:</strong> This MSBuild item group* corresponds to the Service Configuration file hosted by the project that was selected for deployment (based on the value of the <span style="font-family: Courier New;" face="Courier New">TargetProfile</span> property), e.g. ServiceConfiguration.Cloud.cscfg.</li>
<li><strong><span style="font-family: Courier New;" face="Courier New">TargetServiceConfiguration</span>:</strong> This MSBuild item group* corresponds to the actual Service Configuration file that will be deployed.&nbsp; This file begins as a copy of <span style="font-family: Courier New;" face="Courier New">SourceServiceConfiguration</span> but may then be transformed based on the selected publish settings.</li>
<li>
<p><strong><span style="font-family: Courier New;" face="Courier New">TransformServiceModel</span>:</strong> This target represents the part of the build and package process that controls transformation of the Service Configuration file.&nbsp; It can be extended by overriding the <span style="font-family: Courier New;" face="Courier New">BeforeTransformServiceModel</span> or <span style="font-family: Courier New;" face="Courier New">AfterTransformServiceModel</span><span style="font-family: Segoe UI;" face="Segoe UI"> targets</span>, or by adding new targets to the <span style="font-family: Courier New;" face="Courier New">CoreTransformServiceModelDependsOn</span> MSBuild property.</p>
</li>
</ul>
<p>*Despite being an item group, it only ever contains a single file.</p>
<p>To add a new transformation step, start by updating the project file (.ccproj).&nbsp; Add a new property group that redefines <span style="font-family: Courier New;" face="Courier New">CoreTransformServiceModelDependsOn</span>, adding a new target to the end of the original value.&nbsp; Next, define the new target; it will now get called during the transformation phase of the package process.&nbsp; In the target, open the file represented by the <span style="font-family: Courier New;" face="Courier New">@(TargetServiceConfiguration)</span>item group, modify it as desired, and then save it.</p>
<p><span style="font-family: Courier New;" face="Courier New">&nbsp; . <br />&nbsp; . <br />&nbsp; . <br />&nbsp; &lt;Import Project="$(CloudExtensionsDir)Microsoft.WindowsAzure.targets" /&gt;&nbsp;&nbsp;&nbsp; <br />&nbsp; &lt;PropertyGroup&gt; <br />&nbsp;&nbsp;&nbsp; &lt;CoreTransformServiceModelDependsOn&gt; <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $(CoreTransformServiceModelDependsOn); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NewServiceConfigurationTransform; <br />&nbsp;&nbsp;&nbsp; &lt;/CoreTransformServiceModelDependsOn&gt; <br />&nbsp; &lt;/PropertyGroup&gt; <br />&nbsp; &lt;Target Name="NewServiceConfigurationTransform"&gt; <br />&nbsp;&nbsp;&nbsp; &lt;!-- Perform transformation of @(TargetServiceConfiguration) here. &ndash;&gt; <br />&nbsp; &lt;/Target&gt; <br />&nbsp; . <br />&nbsp; . <br />&nbsp; .</span></p>
<p>To see a practical example of this technique used to workaround an issue encountered by some customers in the v1.7 Tools, read <a href="http://social.msdn.microsoft.com/Forums/en-US/windowsazuredevelopment/thread/70f7f535-9d3b-49db-b71a-edb9bcec22ea">this MSDN forum post</a>.</p>
<h4>Don&rsquo;t Forget the Service Definition File!</h4>
<p>The Service Definition (.csdef) file is intended to be the same across all deployments of a Windows Azure application.&nbsp; This is why it&rsquo;s located in the package rather than alongside the package like the Service Configuration file.&nbsp; However, there are still scenarios where a developer may wish to change the Service Definition dynamically, based on the environment for which the application is packaged.&nbsp; Even though the Tools do not support multiple Service Definition files hosted by a project, they undergo a very similar transformation process that can be extended in the same way, using similar MSBuild concepts:</p>
<ul>
<li><strong><span style="font-family: Courier New;" face="Courier New">SourceServiceDefinition</span>:</strong> This MSBuild item group* corresponds to the Service Definition file hosted by the project, e.g. ServiceDefinition.csdef.</li>
<li><strong><span style="font-family: Courier New;" face="Courier New">TargetServiceDefinition</span>:</strong> This MSBuild item group* corresponds to the actual Service Definition file that will be packaged.&nbsp; This file begins as a copy of <span style="font-family: Courier New;" face="Courier New">SourceServiceDefinition</span> but may then be transformed based on the selected publish settings.</li>
</ul>
<p>*Despite being an item group, it only ever contains a single file.</p>
<p>You can apply transformations to the Service Definition file using the <span style="font-family: Courier New;" face="Courier New">@(TargetServiceDefinition)</span>item group in the same target as you do the Service Configuration file.</p>
<h4>Project File Customization or Common Target?</h4>
<p>If the transformation scenario is specific to a single Windows Azure project, then it makes sense to alter the build and package process via that project file directly.&nbsp; However, if the scenario is common it may make sense to split out the customization into a separate targets file.&nbsp; This target file can then be imported in various ways depending on how commonly it&rsquo;s needed:</p>
<ul>
<li><strong>(Option #1) Import the targets directly from the project:</strong> In this option, the targets file is stored in a well-known location (preferably in a path that can be specified relative to any project which has occasion to use it).&nbsp; The project file is then modified by hand to import the targets file after the import of the Windows Azure targets file.&nbsp; This option is suitable when a limited, related set of Windows Azure projects (e.g. within the same solution) need the same customization.</li>
<li><strong>(Option #2) Globally import the targets:</strong> In this option, the targets file is placed in a well known location on the machine which will cause it to be automatically imported by <em>every</em> Windows Azure application on that machine.&nbsp; This option is suitable when <em>any</em> Windows Azure project might need the same customization.&nbsp; To have a target file imported automatically by all Windows Azure projects, add the file to this location:</li>
</ul>
<blockquote>
<p><span style="font-family: Courier New;" face="Courier New">&lt;Program Files (x86)&gt;\MSBuild\Microsoft\VisualStudio\&lt;VS Version&gt;\Windows Azure Tools\&lt;Tools Version&gt;\ImportAfter\</span></p>
</blockquote>
<blockquote>
<p>For example, on a machine with Visual Studio 2012 installed and version 1.7 of the tools the location would be:</p>
<p><span style="font-family: Courier New;" face="Courier New">C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v11.0\Windows Azure Tools\1.7\ImportAfter\</span></p>
</blockquote>
<blockquote>
<p>Note that, since this target is imported by <em>all</em> Windows Azure projects on the machine, it should be robust enough to handle cases where the customization is not necessary.</p>
</blockquote>
<h4>But I Want Web.config-style Transforms!</h4>
<p>A common question is &ldquo;why don&rsquo;t the Tools support multiple Service Configuration files using web.config-style transforms?&rdquo;&nbsp; (This transformation mechanism is being more commonly referred to as <a href="http://visualstudiogallery.msdn.microsoft.com/69023d00-a4f9-4a34-a6cd-7e854ba318b5">SlowCheeta</a>.)&nbsp; Well, the short answer is: because the Tools has a designer over the Service Model files and web.config does not.&nbsp; Using multiple, complete, configuration files to represent different configuration environments is far less complex to automate via a design surface like the Role Editor (a.k.a. Service Model UI).&nbsp; In addition, it&rsquo;s easier for the beginning Windows Azure developer to understand complete files and not be forced to learn the complex XML matching and transformation syntax.</p>
<p>For those that still want web.config-style transformations, you can use the same techniques described above to get close to the familiar web application project experience.&nbsp; Start by updating the project file (.ccproj).&nbsp; Add a new property group that redefines <span style="font-family: Courier New;" face="Courier New">CoreTransformServiceModelDependsOn</span>, adding a new target to the end of the original value.&nbsp; Next, add a <span style="font-family: Courier New;" face="Courier New">UsingTask</span> element that refers to the <span style="font-family: Courier New;" face="Courier New">TransformXml</span> task in the web application publishing tasks assembly.&nbsp; Define the new target; it will now get called during the transformation phase of the package process.&nbsp; In the target, call the <span style="font-family: Courier New;" face="Courier New">TransformXml</span> task using the <span style="font-family: Courier New;" face="Courier New">@(TargetServiceConfiguration)</span> item group as both the source and destination, and specify an arbitrary transform file.&nbsp; In the example below, I&rsquo;m choosing a transform file based on the current <span style="font-family: Courier New;" face="Courier New">TargetProfile</span>.&nbsp; For example, if the <span style="font-family: Courier New;" face="Courier New">TargetProfile</span> is &ldquo;Cloud&rdquo; meaning the ServiceConfiguration.Cloud.cscfg file will be deployed, the task will transform the source file using the file ServiceConfiguration.Cloud.Transform.cscfg, if it exists.&nbsp; (If it does not exist, no transform is performed.)</p>
<p><span style="font-family: Courier New;" face="Courier New">. <br /> . <br /> . <br />&lt; Import Project="$(CloudExtensionsDir)Microsoft.WindowsAzure.targets" /&gt; <br />&lt; PropertyGroup&gt; <br />&nbsp; &lt; CoreTransformServiceModelDependsOn&gt; <br />&nbsp;&nbsp;&nbsp; $(CoreTransformServiceModelDependsOn); <br />&nbsp;&nbsp;&nbsp; PerformXmlTransform; <br />&nbsp; &lt;/CoreTransformServiceModelDependsOn&gt; <br />&lt; /PropertyGroup&gt;</span></p>
<p><span style="font-family: Courier New;" face="Courier New"></span></p>
<p><span style="font-family: Courier New;" face="Courier New">&lt;UsingTask TaskName="TransformXml" AssemblyFile="$(MSBuildExtensionsPath)\Microsoft\VisualStudio\v11.0\Web\Microsoft.Web.Publishing.Tasks.dll" /&gt;</span></p>
<p><span style="font-family: Courier New;" face="Courier New"></span></p>
<p><span style="font-family: Courier New;" face="Courier New">&lt;Target Name="PerformXmlTransform" Condition=" Exists('ServiceConfiguration.$(TargetProfile).Transform.cscfg') "&gt;</span></p>
<p><span style="font-family: Courier New;" face="Courier New"></span></p>
<p><span style="font-family: Courier New;" face="Courier New">&nbsp; &lt;TransformXml Source="@(TargetServiceConfiguration)" <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Transform="ServiceConfiguration.$(TargetProfile).Transform.cscfg" <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Destination="@(TargetServiceConfiguration)" /&gt;</span></p>
<p><span style="font-family: Courier New;" face="Courier New"></span></p>
<p><span style="font-family: Courier New;" face="Courier New">&nbsp; &lt;Message importance="high" Text="Transformed @(TargetServiceConfiguration) using ServiceConfiguration.$(TargetProfile).Transform.cscfg." /&gt; <br />&nbsp; <br />&lt; /Target&gt; <br /> . <br /> . <br /> .</span></p>
<p>To sum up, if you are willing to spend some time to learn a few basic MSBuild concepts, the Windows Azure Tools for Visual Studio offers a lot of packaging flexibility.&nbsp; If you have custom packaging scenarios that the Tools do not support directly, consider using the Tools extensibility to add your own!</p>